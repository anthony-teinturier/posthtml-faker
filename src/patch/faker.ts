import { IFaker } from "faker";

/**
 * Compiled regular expression to match mustache expressions.
 */
const ANY_MUSTACHES = /\{\{\s*(?:([^(]+?)(?:\(([^)]*)\))?)?\s*\}\}/g;

/**
 * Creates a new implementation of the `Faker.fake` method from the _Faker.js_
 * module, to correct issues ([#643](https://github.com/Marak/faker.js/issues/643)
 * and [#407](https://github.com/Marak/faker.js/issues/407)) and to improve
 * its syntax (e.g., handling spaces and line breaks).
 *
 * @param faker The _Faker.js_ instance.
 * @returns The new implementation of the `Faker.fake` method.
 */
export function patchFake(faker: object): (str: string) => string {
  return parseMustaches.bind(null, faker);
}

/**
 * Given a mustache formatted string, it replaces each mustache content with the
 * value generated by the method defined in those mustaches.
 *
 * @param faker The _Faker.js_ instance.
 * @param str The formatted string.
 * @returns The interpolated result string.
 */
function parseMustaches(faker: IFaker, str: string): string {
  if (str.trim().length === 0) {
    return "";
  }

  return str.replace(ANY_MUSTACHES, (_, rawNamespace, rawParameters) => {
    if (rawNamespace === undefined || rawNamespace.trim().length === 0) {
      return "";
    }

    const namespace = parseNamespace(faker, rawNamespace);
    const parameters = parseParameters(rawParameters);

    return namespace.apply(faker, parameters);
  });
}

/**
 * Given a formatted namespace, it searches in the _Faker.js_ API, the defined
 * method implementation.
 *
 * @param faker The _Faker.js_ instance.
 * @param namespace The formatted namespace.
 * @returns The method implementation.
 * @throws When no method is defined in the namespace.
 */
function parseNamespace(faker: IFaker, namespace: string): () => any {
  const [module, method] = namespace.split(".", 2);

  if (method === undefined) {
    throw new Error(`No method defined in the namespace "${namespace}"`);
  }

  return findImplementation(faker, module.trim(), method.trim());
}

/**
 * Given a module name and a method name, it searches in the _Faker.js_ API the
 * method implementation.
 *
 * @param faker The _Faker.js_ instance.
 * @param moduleName The module name.
 * @param methodName The method name.
 * @returns The method implementation.
 * @throws When the module does not exist in the _Faker.js_ instance.
 * @throws When the method does not exist in the module.
 */
function findImplementation(
  faker: IFaker,
  moduleName: string,
  methodName: string
): () => any {
  if (!(moduleName in faker)) {
    throw new Error(`The module "${moduleName}" does not exist in Faker.js`);
  }

  const fakerModule = faker[moduleName];

  if (!(methodName in fakerModule)) {
    throw new Error(
      `The method "${methodName}" does not exist in the Faker.js module "${moduleName}"`
    );
  }

  return fakerModule[methodName];
}

/**
 * Given a list of parameters formatted as a list of _JSON_ values, it converts
 * the defined parameters as JavaScript values.
 *
 * @param parameters The formatted parameters.
 * @returns The parameters.
 * @throws When the formatted parameters is not a valid _JSON_ string.
 */
function parseParameters(parameters: string): any[] {
  if (parameters === undefined) {
    return [];
  }

  return JSON.parse(`[${parameters}]`);
}
